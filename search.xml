<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【二叉树】104 二叉树的最大深度</title>
    <url>/2022/01/10/20-22-59/</url>
    <content><![CDATA[<h5 id="题目">题目</h5>
<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104 二叉树的最大深度</a></p>
<h5 id="思路一">思路一</h5>
<p><strong>分解的思想</strong>：先计算左子树的最大深度，再计算右子树的最大深度，最后比较两个深度的最大值再加上本结点，结果就是二叉树的最大深度。这也是后序遍历的思想。</p>
<span id="more"></span>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">int</span> res = Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="思路二">思路二</h5>
<p><strong>遍历的思想</strong>：在遍历一棵二叉树的过程中计算最大深度，即用一个变量记录每个结点的深度，取最大值就是最大深度。</p>
<p><strong>depth++和depth–不好理解，这里要深入理解前中后序遍历，前中后序遍历的区别不仅仅是遍历序列不同，前中后序遍历最本质的不同是：在遍历过程中对每个节点都会经过三次，在哪一次对结点进行操作决定了是哪一种遍历。</strong></p>
<p><strong>前序遍历：对结点的操作放在第一次经过该节点的时候。</strong></p>
<p><strong>中序遍历：对结点的操作放在第二次经过该节点的时候（一个二叉树节点的左子树都遍历完，即将开始遍历右子树的时候）。</strong></p>
<p><strong>后序遍历：对结点的操作放在第三次经过该结点的时候。</strong></p>
<p>对于这道题：刚进入一个结点时depth++，最后离开该结点时说明<strong>该访问右子树了</strong>，此时depth要减1。</p>
<h5 id="代码-v2">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;  <span class="comment">//记录最大深度</span></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;  <span class="comment">//当前节点的所处的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            res = Math.max(res,depth);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;  <span class="comment">//前序遍历的位置，首次进入一个结点，深度加1</span></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">        depth--;  <span class="comment">//后序遍历的位置，最后一次经过该节点，离开该节点后depth减1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉树】105 从前序与中序遍历序列构造二叉树</title>
    <url>/2022/01/03/18-42-15/</url>
    <content><![CDATA[<h1>题目</h1>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a></p>
<hr>
<h1>思路</h1>
<p><strong>前序遍历从左到右都是根，在中序遍历中这个根的左边的数字是它的左子树，它右边的数字是它的右子树。</strong></p>
<p>2.构造一棵二叉树，最重要的是确定根节点，然后再用同样的方法得到根的左子树和右子树，这是根左右的前序遍历框架。</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//preOrder[preStart...preEnd]:前序遍历数组</span></span><br><span class="line"><span class="comment">//inOrder[inStart...inEnd]:中序遍历数组</span></span><br><span class="line"><span class="comment">//返回根节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preOrder,<span class="keyword">int</span> preStart,<span class="keyword">int</span> preEnd,vector&lt;<span class="keyword">int</span>&gt;&amp; inOrder,<span class="keyword">int</span> inStart,<span class="keyword">int</span> inEnd)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获得根节点的数值</span></span><br><span class="line">    <span class="keyword">int</span> rootVal = preOrder[preStart];</span><br><span class="line">    <span class="comment">//获得根节点在中序遍历数组中的索引位置</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rootVal == inOrder[i])&#123;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建以rootVal为根节点的树</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line">    <span class="comment">//递归创建左子树和右子树</span></span><br><span class="line">    root-&gt;left = <span class="built_in">build</span>(preOrder,?,?,inOrder,?,?);</span><br><span class="line">    root-&gt;right = <span class="built_in">build</span>(preOrder,?,?,inOrder,?,?);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.确定函数的参数及参数怎么写在这道题中是一个比较难的点。</p>
<p>（1）都有哪几个参数</p>
<p>前序遍历数组preOrder，前序遍历数组开始下标preStart，前序遍历数组结束下标preEnd；</p>
<p>中序遍历数组inOrder，中序遍历数组开始下表inStart，中序遍历数组结束下标inEnd；</p>
<p>（2）参数如何确定</p>
<p>对于中序遍历数组中的参数来说比较容易想到，它们分别是inStart ~ index - 1 和 index + 1 ~ inEnd</p>
<p>对于前序遍历数组中的参数来说需要知道左子树长度才可以进一步确定参数。</p>
<p>左子树的长度通过index - inStart获得，把它叫做leftSize吧。</p>
<p>那么前序遍历中的参数就是preStart + 1 ~ preStart + leftSize 和 preStart + leftSize + 1 ~ preEnd</p>
<hr>
<h1>代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(preorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>() - <span class="number">1</span>,inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//preOrder[preStart...preEnd]:前序遍历数组</span></span><br><span class="line">    <span class="comment">//inOrder[inStart...inEnd]:中序遍历数组</span></span><br><span class="line">    <span class="comment">//返回根节点</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preOrder,<span class="keyword">int</span> preStart,<span class="keyword">int</span> preEnd,vector&lt;<span class="keyword">int</span>&gt;&amp; inOrder,<span class="keyword">int</span> inStart,<span class="keyword">int</span> inEnd)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果起始索引大于结束索引则返回空</span></span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得根节点的数值</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = preOrder[preStart];</span><br><span class="line">        <span class="comment">//获得根节点在中序遍历数组中的索引位置</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rootVal == inOrder[i])&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到左子树的长度</span></span><br><span class="line">        <span class="keyword">int</span> leftSize = index - inStart;</span><br><span class="line">        <span class="comment">//创建以rootVal为根节点的树</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">//递归创建左子树和右子树</span></span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(preOrder,preStart + <span class="number">1</span>,preStart + leftSize,inOrder,inStart,index - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(preOrder,preStart + leftSize + <span class="number">1</span>,preEnd,inOrder,index + <span class="number">1</span>,inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉树】106 从中序遍历和后序遍历构造二叉树</title>
    <url>/2022/01/04/22-24-52/</url>
    <content><![CDATA[<h1>题目</h1>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106 从中序遍历和后序遍历构造二叉树</a></p>
<hr>
<h1>思路</h1>
<p>本题思路与<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a>类似，唯一需要思考的地方是创建左右子树的时候参数是什么。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以此树为例</span><br><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   3</span><br><span class="line">   / \ / \</span><br><span class="line">  5  4 8  9</span><br><span class="line">    / \</span><br><span class="line">   6   7</span><br></pre></td></tr></table></figure>
<p>中序遍历结果：26471839</p>
<p>后序遍历结果：67428931</p>
<hr>
<h1>代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inOrder, vector&lt;<span class="keyword">int</span>&gt;&amp; postOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(inOrder,<span class="number">0</span>,inOrder.<span class="built_in">size</span>() - <span class="number">1</span>,postOrder,<span class="number">0</span>,postOrder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inOrder,<span class="keyword">int</span> inStart,<span class="keyword">int</span> inEnd,vector&lt;<span class="keyword">int</span>&gt;&amp; postOrder,<span class="keyword">int</span> postStart,<span class="keyword">int</span> postEnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inStart &gt; inEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = postOrder[postEnd];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inOrder.<span class="built_in">size</span>() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(value == inOrder[i])&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(value);</span><br><span class="line">        <span class="keyword">int</span> leftSize = index - inStart;</span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(inOrder,inStart,index - <span class="number">1</span>,postOrder,postStart,postStart + leftSize - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(inOrder,index + <span class="number">1</span>,inEnd,postOrder,postStart + leftSize,postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>语法</h1>
<p>对于一个数组，从第一个元素的下标到最后一个元素的下标是<strong>0 ~ nums.size()  - 1</strong></p>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉树】114 二叉树展开为链表</title>
    <url>/2022/01/01/12-57-01/</url>
    <content><![CDATA[<h1>题目</h1>
<p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114 二叉树展开为链表</a></p>
<hr>
<h1>思路</h1>
<p><strong>1.将二叉树展开成链表是怎么一个过程</strong></p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以形如此的二叉树A为例：</span><br><span class="line">         1     </span><br><span class="line">        / \</span><br><span class="line">       2   5</span><br><span class="line">二叉树A转换成链表的过程是：</span><br><span class="line">         1             1</span><br><span class="line">        / \  -----&gt;     \</span><br><span class="line">       2   5             2</span><br><span class="line">                          \</span><br><span class="line">                           5</span><br></pre></td></tr></table></figure>
<p><strong>2.定义函数flatten的功能</strong></p>
<p>函数flatten的功能是把一棵二叉树展开成一个链表</p>
<p><strong>3.运用框架</strong></p>
<p>对于一个节点，把它的左子树展开成一个链表，再把它的右子树展开成一个链表，最后再对以该节点为根节点的树展开成链表。<strong>这是左右根的后序遍历框架。</strong></p>
<p><strong>4.例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1              1               1</span><br><span class="line">   / \            / \               \</span><br><span class="line">  2   3  ----&gt;   2   3  ----&gt;        2</span><br><span class="line"> / \ / \          \   \               \</span><br><span class="line">4  5 6  7          4   6               4</span><br><span class="line">                    \   \               \</span><br><span class="line">                     5   7               5</span><br><span class="line">                                          \</span><br><span class="line">                                           3</span><br><span class="line">                                            \</span><br><span class="line">                                             6</span><br><span class="line">                                              \</span><br><span class="line">                                               7</span><br></pre></td></tr></table></figure>
<hr>
<h1>代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">flatten</span>(root-&gt;left);  <span class="comment">//把左子树展开成链表</span></span><br><span class="line">        <span class="built_in">flatten</span>(root-&gt;right); <span class="comment">//把右子树展开成链表</span></span><br><span class="line">        <span class="comment">//记录下根的左右子树（左右子树均已展开成链表）</span></span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        TreeNode* right = root-&gt;right;</span><br><span class="line">        <span class="comment">//对根节点进行操作</span></span><br><span class="line">        <span class="comment">//1.将左子树接到右子树的位置</span></span><br><span class="line">        root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="comment">//2.将原来的右子树接到现在的右子树下边</span></span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">while</span>(node-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉树】116 填充每个结点的下一个右侧结点指针</title>
    <url>/2021/12/31/23-25-30/</url>
    <content><![CDATA[<h1>题目</h1>
<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116 填充每个结点的下一个右侧结点指针</a></p>
<hr>
<h1>思路</h1>
<p>1.题目的要求：使每个结点的指针指向它右侧的结点。</p>
<p>2.对于每一个结点要做的事情：让其左子树的根结点指向右子树的根结点。举例：对于1来说，是让2指向3 。</p>
<span id="more"></span>
<p>所以写一个函数A，其功能是让其左子树的根结点指向右子树的根结点。</p>
<p>3.对于一个结点，先对该结点进行“让其左子树的根结点指向右子树的根结点”功能，再对其左右子树做同样的操作，这是<strong>根左右的前序遍历框架</strong>。</p>
<p>4.但是依照上述操作不会使5指向6，因为对2进行该函数可以使4指向5，对3进行该函数可以使6指向7，但都无法使5指向6 。</p>
<p>5.所以改变函数A的功能，使其功能变为：使结点root1指向结点root2。对于一个结点，对该结点和其左右子结点进行完该函数后，还要加上5指向6这种情况。</p>
<hr>
<h1>代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">connectTowNode</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接两个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectTowNode</span><span class="params">(Node* node1,Node* node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="literal">nullptr</span> || node2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前序遍历</span></span><br><span class="line">        node1-&gt;next = node2;</span><br><span class="line">        <span class="comment">//连接具有相同父结点的两个子树</span></span><br><span class="line">        <span class="built_in">connectTowNode</span>(node1-&gt;left,node1-&gt;right);</span><br><span class="line">        <span class="built_in">connectTowNode</span>(node2-&gt;left,node2-&gt;right);</span><br><span class="line">        <span class="comment">//连接具有不同父结点的两棵子树</span></span><br><span class="line">        <span class="built_in">connectTowNode</span>(node1-&gt;right,node2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉树】124 二叉树的最大路径和</title>
    <url>/2022/01/14/23-15-07/</url>
    <content><![CDATA[<h5 id="题目">题目</h5>
<p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124 二叉树的最大路径和</a></p>
<h5 id="思路">思路</h5>
<p>对于经过某节点的最大路径和等于什么？若左子树的单边最大路径长度小于0，右子树的单边路径长度也小于0，那么经过该结点的单<span id="more"></span>边路径长度等于该结点的值。如果左右子树的单边最大路径长度有大于0的，才加到该结点的值上组合到一起成为经过该结点的最大路径和。</p>
<p>因此本题的思路是在计算单边最大路径和的遍历过程中在后续位置上顺便计算每个节点的最大路径和并更新最大值。</p>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        oneSideMax(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*辅助函数：在计算以root为根节点的最大单边路径长度的过程中计算最大路径和 ，这是一个后序遍历的过程*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">oneSideMax</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftSizeMax = oneSideMax(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightSizeMax = oneSideMax(root.right);</span><br><span class="line">        <span class="comment">/*顺便计算这个根节点的最大路径和，并更新最大值 */</span></span><br><span class="line">        <span class="comment">//为什么要设置这两个判断？因为如果左右子树最大单边路径长度&lt;0，</span></span><br><span class="line">        <span class="comment">//那么对于增加此时的根节点的最大单边路径长度是没有帮助的，所以设置为0</span></span><br><span class="line">        <span class="keyword">if</span>(leftSizeMax &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            leftSizeMax = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightSizeMax &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            rightSizeMax = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootPathMax = leftSizeMax + rightSizeMax + root.val;  <span class="comment">//为什么一定要加上root.val，因为这就是要计算经过此结点的最大路径和</span></span><br><span class="line">        res = Math.max(res,rootPathMax);</span><br><span class="line">        <span class="comment">/*计算根节点的最大单边路径长度 */</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftSizeMax,rightSizeMax) + root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：这道题的思路和<a href="https://winterwintersweet.github.io/2022/01/11/21-13-28/#more">【二叉树】543 二叉树的直径</a>的思路二是相同的。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉树】1373 二叉搜索树的最大键值和</title>
    <url>/2022/01/09/22-54-05/</url>
    <content><![CDATA[<h5 id="题目">题目</h5>
<p><a href="https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/">1373 二叉搜索树的最大键值和</a></p>
<h5 id="思路">思路</h5>
<p>首先要判断都有哪些是二叉搜索树，再求出键值和，更新最大值。</p>
<span id="more"></span>
<p>找线索二叉树：先判断左右子树是不是二叉搜索树，再用本结点的值和左子树的最大值比较，和右子树的最小值比较。</p>
<p>找一颗树的最大值/最小值：找左子树的最大值/最小值，找右子树的最大值/最小值，再和根节点的值比较</p>
<p>求一棵树的结点值的和：先求左子树的和，再求右子树的和，最后加上根节点的值。</p>
<p>以上都表明这道题用后序遍历好做。</p>
<p>技巧是设置一个四个单位的数组：</p>
<p>res[0]:1表示以该节点为根的二叉树是二叉搜索树</p>
<p>res[1]:存储以该节点为根的二叉树的最小值</p>
<p>res[2]:存储以该节点为根的二叉树的最大值</p>
<p>res[3]:存储以该节点为根的二叉树的键值和</p>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;  <span class="comment">//全局变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">if</span>(max &lt; <span class="number">0</span>)&#123;  <span class="comment">//所有节点都为复数时，输出的是0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*辅助函数：在遍历二叉树的过程中找到BST并找出最大键值和 */</span></span><br><span class="line">    <span class="keyword">int</span>[] traverse(TreeNode root)&#123;</span><br><span class="line">        <span class="comment">//如果是空结点，返回的数组中第一个元素是1，即“空”不会影响二叉搜索树，所以看作是二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] b = &#123;<span class="number">1</span>,Integer.MAX_VALUE,Integer.MIN_VALUE,<span class="number">0</span>&#125;;  <span class="comment">//怎么表示一个有值的数组，最大值最小值怎么表示</span></span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分别遍历左右子树形成对应的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] left = traverse(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] right = traverse(root.right);</span><br><span class="line">        <span class="comment">//后序遍历对根节点的操作</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]; </span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; root.val &gt; left[<span class="number">2</span>] &amp;&amp; root.val &lt; right[<span class="number">1</span>])&#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>] = Math.min(root.val,left[<span class="number">1</span>]);</span><br><span class="line">            res[<span class="number">2</span>] = Math.max(root.val,right[<span class="number">2</span>]);</span><br><span class="line">            res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line">            max = Math.max(max,res[<span class="number">3</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉树】144 二叉树的前序遍历</title>
    <url>/2022/01/11/19-41-17/</url>
    <content><![CDATA[<h5 id="题目">题目</h5>
<p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144 二叉树的前序遍历</a></p>
<h5 id="思路一">思路一</h5>
<p><strong>遍历</strong>的思路，在前序遍历的过程中把每个结点放到集合中，前序遍历。</p>
<span id="more"></span>
<h5 id="代码一">代码一</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*辅助函数：前序遍历二叉树*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="思路二">思路二</h5>
<p><strong>分解</strong>的思路，因为前序遍历二叉树形成的数组形式是这样的。</p>
<img align = "center" src = "https://cdn.jsdelivr.net/gh/winterwintersweet/image/202201112003890.png" width = "400" height = "260">
<p>把根节点加入list，再把左子树的前序序列加入list，再把右子树的前序序列加入list</p>
<h5 id="代码二">代码二</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;  <span class="comment">//深入到了叶节点下边，此时list中也有元素啊，也要返回list</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把根节点添加到集合list中</span></span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="comment">//把左子树变成一个集合，在把集合中的所有元素添加到集合list中</span></span><br><span class="line">        list.addAll(preorderTraversal(root.left));</span><br><span class="line">        <span class="comment">//把右子树变成一个集合，再把结合中的所有元素添加到集合list中</span></span><br><span class="line">        list.addAll(preorderTraversal(root.right));</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="语法">语法</h5>
<p>将一个集合中的所有元素添加到另一个结合中的给定位置。</p>
<p><code>void addAll(int i, Collection&lt;? extends E&gt; c);</code></p>
<p>i：用于指定集合c的第一个元素插入的位置</p>
<p>c: 把集合c中的元素插入进去</p>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>2021年度总结</title>
    <url>/2022/01/01/20-21-22/</url>
    <content><![CDATA[<h4 id="写在前面">写在前面</h4>
<p>2021年已经过去了，这是我人生中很重要的一年，从2021年的1月1日起我就开始了考研的备考之路，一直持续到12月24日，所以我想回顾一下这一年的备考过程，写下我的一些思考和获得的启示，以后的路可能会走得更顺畅些。</p>
<span id="more"></span>
<img align = "center" src = "https://cdn.jsdelivr.net/gh/winterwintersweet/image/202201061738857.jpg" width = "470" height = "360">
<p align = "center"> <font size = "2"> 考研自习室</font></p>
<h6 id="从单词和数学每日一题的角度思考坚持。">从单词和数学每日一题的角度思考坚持。</h6>
<p>我记得我买了一本单词书，但那本书我只看了几页，后来全年都在用单词软件背单词。通过单词软件会自动推送它认为我不会的单词，我每天会背90个学过的单词，30个新单词。这样的背诵一直持续到暑假，我还自创了一套背单词的方法，但后来证明这种方法是费力不讨好的，这一点还会和下面的一些内容相联系。暑假过后开学回到学校，不知怎么的，我再也一天背不了120个单词了，而且是处于一种这一天想背背单词了，就随便背一下这样的状态，背20来个……而且在次数上也是三天打鱼两天晒网。数学的每日一题就更加悲观了，我只是在暑假在外边租房的那20天的时间集中写了50道题左右，其他时间一概没有做。现在想起来，我觉得有两点需要注意：**第一：坚持就是要每天都做，第二，既然每天都做，一次就不要做太多。不积跬步无以至千里，不积小流无以成江海。既要“积”，也要“跬步”和“小流”。写到这里，忽然想起了李娟文章中的一句话：”好吧，常年在河中拦网守候的人，总比隔三岔五空着手到水边碰运气的人收获稍多。“**想想看，这些古文和李娟文中的话我都曾读过，但这也是我走过弯路，吃过亏之后才真正理解了这些话。</p>
<h6 id="从408的角度思考选择、笔记中自我感动的努力与实际效果的差异、学了又忘记。">从408的角度思考选择、笔记中自我感动的努力与实际效果的差异、学了又忘记。</h6>
<p>当初选择408作为专业课是经历了很大的心理建设的，我一开始想选择的是两门专业课，后来发现两门专业课的学校并不是我想去的学校，又想到408作为统考科目，将来如果考得不好走调剂相对容易些，就选了408。至今，你问我408是一个正确的选择吗？我仍不能说它不是，但是这里面涉及到一个对自身能力的客观评价和一种心理现象，具体来说是这样的：408是所有计算机专业课里难度最大的，以我的专业知识水平做408很难，第二个是如果我挑一个比较难的，那么我就更有理由一些题不会了。虽然有上述缺点，但是就是靠调剂相对容易我才把408坚持了下来。话说回来，按照现在的形势，408统考已经成为必然，几乎不存在选择的问题了。但还是想说一下，以后肯定还会面临更多的选择，到底什么样的选择才是更符合自己的呢？我觉得有两点：<strong>第一：根据目的进行选择，就是说我的目的是上研究生，即使调剂也可以，那么选408我就大概率有学上。第二：在根据目的进行选择的基础上挑选相对简单的路，不要挑选最难的，要正确看待自己的水平。</strong></p>
<p>再来说一下笔记的问题，专业课一共四门，每门课我都做了大量笔记，不可否认，它们起了作用，但是我在笔记上面花的时间太多了，笔记很好却没有记到心中，却不会运用，笔记再好再多又有什么用呢？我只会沉浸到一种假努力的自我感动中，那么，这篇总结会成为自我感动吗？那要看我今后是不是自觉躬身实践了。<strong>以后如果真上了研究生，我不会再做大量笔记了，我会把辅导书作为笔记本，其它的进行补充，我以前从没有这样做过，我一定要尝试一次。</strong></p>
<p>408还有一个最令人窒息的问题就是学了又忘，其实这一点在每个学科上都有体现，但尤其是408和线性代数体现的最为明显。我学了计组，就把数据结构忘完了，学完操作系统，就又把计组忘完了……我知道，遗忘是一个必然的规律，但有什么好的办法可以使我对知识的印象可以停留地更久呢？我想到，为什么高中的时候这种遗忘的感觉不这么强烈，我觉得原因是高中的时候我们一天会接触好几门科目，相对分散，而在考研备考的过程中我都是拿出一整块的时间复习一门科目，然后再拿出一整块的时间来复习令一门科目，这样当然就遗忘地快了。还有一个原因是我从来没有对学过的知识进行过复习，比方说一周拿出一天的时间来对这一周所有学过的知识和做过的错题做一个回顾，我没有。我总认为一天的时间多学点知识多好啊。那么，解决学了又忘这个问题的方法也就找到了：<strong>第一：把所有要学的知识分散开，比方有4门课，那么就要一天这四门课都看，或者每天看三门轮流着看。第二：每周一定要拿出时间来进行回顾，不要再觉得这是浪费时间了，所谓磨刀不误砍柴工，吃这个亏吃的还少吗？</strong></p>
<h6 id="从数学的角度思考熟练">从数学的角度思考熟练</h6>
<p>我这个人不聪明，说勤奋吧有的时候也是傻勤奋，考研到最后阶段才认识一位数学非常棒的up主——没咋了。下面的一些总结来自他的视频，主要说明了做题的意义是什么，或者说做题的时候要有意地往什么方向使劲。<strong>第一：做题要实现审题上、思考上以及计算上的简化流程，最终达成又对又快的效果，下面具体说明：审题上简化流程：你对题目给出的一些特定条件如何处理使用形成了自己的理解，你的脑子里很快反应出相应的一系列处理方式；思考上的简化流程：把一系列的操作打包成块，灵活运用，尤其体现在对二级结论的熟练使用上。不要每次碰到新的题目就像碰到一个崭新的问题一样；计算上的简化流程：要总结计算过程，进行适当的跳步，这样才能快。第二：做题可以帮助我更深刻理解概念定理。</strong></p>
<h6 id="从算法的角度思考畏惧">从算法的角度思考畏惧</h6>
<p>大学的遗憾之一就是没有认真搞算法，这几年就参加过一次蓝桥杯，也没有拿个名次。动过很多次想法说该练算法了，最后都已没有时间，还有别的事情等等理由不去做算法题，归根到底，这源自我内心的畏惧，我觉得算法题很难，我不敢也不想去做。大二还是大三的时候我们上过算法课，当时是疫情，我不太适应那位老师的教学方式，我感觉他总是他题目故意说的高大精深，而不是从学生的角度去考虑，总之，那半年的算法课浪费了。<strong>但现在已经到了不做不行的时候了，其实你说它有什么可怕的呢？一个题而已，况且现在有了这么多的网络资源可以供我学习，每天做一道题，慢慢的就会喜欢上算法了，难就难在敢不敢踏出第一步。</strong></p>
<h5 id="结束语">结束语</h5>
<p>以上的总结全部与学习或专业能力相关，并没有涉及其它方面😕……</p>
<p>**纸上得来终觉浅，绝知此事要躬行。**我不求我能做到在新的一年完完全全用上面的思想指导我接下来的学习，能用上一半我就已经很知足了。</p>
<p>​                                                                                                                                                                                                       2022年1月1日</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉搜索树】230 二叉搜索树第k小的元素</title>
    <url>/2022/01/18/21-31-40/</url>
    <content><![CDATA[<h5 id="题目">题目</h5>
<p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230 二叉搜索树第k小的元素</a></p>
<h5 id="思路">思路</h5>
<p>二叉搜索树的三个重要性质<span id="more"></span></p>
<p>1.对于BST的每一个结点node，左子树结点的值都小于node的值，右子树结点的值都大于node的值。</p>
<p>2.对于BST的每一个结点，左子树和右子树都是BST</p>
<p>3.BST中序遍历的结果是升序序列。</p>
<p>对于本题</p>
<p>利用中序遍历的结果是升序序列来做。</p>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = -<span class="number">1</span>;  <span class="comment">//存储第k小的结点的值</span></span><br><span class="line">    <span class="keyword">int</span> rank = <span class="number">0</span>;  <span class="comment">//存放当前节点的排名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        traverse(root,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//辅助函数：中序遍历BST，在中序遍历的位置挑出第k小的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.left,k);</span><br><span class="line">        rank++;</span><br><span class="line">        <span class="keyword">if</span>(rank == k)&#123;</span><br><span class="line">            res = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉树】515 在每个树行中找最大值</title>
    <url>/2022/01/15/21-37-43/</url>
    <content><![CDATA[<h5 id="题目">题目</h5>
<p><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/">515 在每个树行中找最大值</a></p>
<h5 id="思路">思路</h5>
<p>利用<strong>遍历的思想</strong>，二叉树的层次遍历，在每一行找出最大值添加到list数组中。</p>
<span id="more"></span>
<p>二叉树层次遍历的框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入一棵二叉树的根节点，层次遍历这棵二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode tree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="comment">//出去一个结点，就把它的左右子树的根节点添加到队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            TreeNode node = q.poll();</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                q.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                q.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个for循环遍历一层结点，整个while循环从上到下遍历完整棵二叉树</p>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestValues</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;  <span class="comment">//这里为什么是list,当给的是一颗空树的时候也要返回一个List&lt;Integer&gt;才可以，函数签名要求的。</span></span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;  <span class="comment">//队列判空怎么写</span></span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode node = q.poll();</span><br><span class="line">                <span class="keyword">int</span> num = node.val;</span><br><span class="line">                max = Math.max(max,num);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉树】226 翻转二叉树</title>
    <url>/2021/12/31/10-44-49/</url>
    <content><![CDATA[<h1>题目</h1>
<p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226 翻转二叉树</a></p>
<h1>思路</h1>
<p>【该做什么】翻转当前节点的左右子树</p>
<p>【什么时候做】先翻转当前节点的左右子树，再对以左右子树根节点为根的子树进行相同的操作，即前序遍历。</p>
<span id="more"></span>
<hr>
<h1>代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对该结点的操作</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line">        <span class="comment">//左右子树</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1>其他解法</h1>
<p>该题还可用<strong>左右根的后序遍历框架</strong>来解决，即对于一个结点，先让左子树翻转它的子节点，再让右子树翻转它的子节点，最后翻转本结点的左右子树。</p>
<hr>
<h1>代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        TreeNode* temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>提交后发现<strong>采用后序遍历用时更少，内存消耗与前序遍历差不多</strong>。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉树】297 二叉树的序列化与反序列化</title>
    <url>/2022/01/08/00-27-02/</url>
    <content><![CDATA[<h5 id="题目">题目</h5>
<p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297 二叉树的序列化与反序列化</a></p>
<h5 id="思路">思路</h5>
<p><strong>什么是序列化和反序列化</strong></p>
<p>二叉树的序列化就是把二叉树转变成字符串，反序列化就是一个字符串变成一棵树。</p>
<span id="more"></span>
<p><strong>具体思路</strong></p>
<p><strong>1.序列化</strong></p>
<p>树的样子：</p>
<img align = "center" src = "https://cdn.jsdelivr.net/gh/winterwintersweet/image/202201072306875.jpg" width = "220" height = "160">
<p>按照前序遍历的方法序列化得到的字符串的样子：1,2,null,null,3,4,null,null,5,null,null</p>
<p><strong>问题：设计什么样的辅助函数</strong></p>
<p>辅助函数的功能是把二叉树变成一个字符串，参数有树和字符串，采用前序遍历的方式，递归结束的条件是树的结点为空。</p>
<p><strong>2.反序列化</strong></p>
<p>字符串：1,2,null,null,3,4,null,null,5,null,null</p>
<p>按照前序遍历的方法得到的树也是上图。</p>
<p>要设置一个辅助函数将字符串变成树。</p>
<p><strong>问题：字符串中的单个字符不好处理，怎么才能更方便的遍历字符串中的每一个结点呢？</strong></p>
<p>但是字符串中一个个单个的字符不好处理，要先把字符串拆成单个的字符串存到一个字符串数组中，再通过通过前序遍历的方法得到一颗树。</p>
<p><strong>问题：只有前序遍历的字符串，能得到二叉树吗?</strong></p>
<p>能得到，因为这个字符串中包含空结点的信息。</p>
<p><strong>问题：辅助函数设计成什么样？</strong></p>
<p>功能是把字符串数组中的内容存到二叉树中，参数就是字符串数组，采用的是前序遍历的方式，递归结束的标志是数组为空。</p>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*主函数：将二叉树序列化为字符串*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder string = <span class="keyword">new</span> StringBuilder();  <span class="comment">//[1]</span></span><br><span class="line">        build(root,string);</span><br><span class="line">        String str = string.toString();  <span class="comment">//[2]</span></span><br><span class="line">        str = str.substring(<span class="number">0</span>,str.length() -<span class="number">1</span>);  <span class="comment">//[3]substring的作用</span></span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*辅助函数：将二叉树存到string中*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(TreeNode root,StringBuilder string)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            string.append(<span class="string">&quot;null&quot;</span>).append(<span class="string">&quot;,&quot;</span>); </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string.append(root.val).append(<span class="string">&quot;,&quot;</span>);  <span class="comment">//[5]这里append可以自动把数字转为字符串</span></span><br><span class="line">        build(root.left,string);</span><br><span class="line">        build(root.right,string);       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*主函数：将字符串反序列化成一棵二叉树*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : data.split(<span class="string">&quot;,&quot;</span>))&#123;  <span class="comment">//[6]sqlit的作用,循环的使用</span></span><br><span class="line">            list.addLast(s);  <span class="comment">//[7]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deFind(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*辅助函数：把list中的内容存到二叉树中*/</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">deFind</span><span class="params">(LinkedList&lt;String&gt; list)</span></span>&#123;  <span class="comment">//[8]注意括号里的写法</span></span><br><span class="line">        <span class="keyword">if</span>(list.isEmpty())&#123;  <span class="comment">//[9]判空，结束条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String string = list.removeFirst();  <span class="comment">//[10]removeFirst功能</span></span><br><span class="line">        <span class="keyword">if</span>(string.equals(<span class="string">&quot;null&quot;</span>))&#123;  <span class="comment">//[11]</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(string));  <span class="comment">//[12]字符串变数字</span></span><br><span class="line">        root.left = deFind(list);</span><br><span class="line">        root.right = deFind(list);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="语法上的一些细节">语法上的一些细节</h5>
<p><strong>1.<code>StringBuiler</code></strong></p>
<p>[1]什么时候用<code>StringBuilder</code>而不是用<code>String</code>呢？</p>
<p>当需要用许多小段的字符串来构建一个大的字符串时使用StringBuilder，因为如果使用字符串拼接的方法效率比较低，每次拼接字符串时都会构建一个新的<code>String</code>对象，既耗时，又费空间。</p>
<p><code>StringBuilder append(String str)</code>和<code>StringBuilder append(Char c)</code>方法就能非常轻松地在字符串末尾追加字符串或字符。</p>
<p>[2]<code>StringBuilder</code>还有一个方法是<code>String toString()</code>，其功能是返回一个与构建器或缓冲器内容相同的字符串。</p>
<p><strong>2.String</strong></p>
<p>[3]<code>String substring(int beginIndex)</code>:返回从beginIndex到末尾的所以字符</p>
<p><code>String substring(int beginIndex,int endIndex)</code>:返回从beginIndex到endIndex - 1的所有字符</p>
<p>[6]data.split(“,”)的功能：将data这个字符串按照 ”,“ 分开，分成好多个小字符串存到一个字符串数组中。</p>
<p><strong>[11]检测字符串相等为什么用equals方法而不是==？</strong></p>
<p>==只能够确定两个字符串是否在同一位置，当然在同一位置的字符串肯定是相等的，但是不在同一位置的字符串也有可能相等。</p>
<p>[12]字符串变数字Integer.parseInt(string)</p>
<p><strong>3.for each循环，也叫增强for循环</strong></p>
<p>[6]例子：for(int element : a) 其中a是个数组，前面是一个存储数组中元素的一个变量。整个语句读作循环a中的每一个元素</p>
<p>适用于处理一个集合中的所有元素，因为这样根本不需要考虑下标的起始值和终止值。</p>
<p><strong>4.LinkedList&lt;&gt;</strong></p>
<p>[7] void addLast(E element)：将某个元素添加到列表的尾部。</p>
<p>[8]如果是一个集合作函数的参数，尖括号中的内容被忘了写<code>TreeNode deFind(LinkedList&lt;String&gt; list)</code></p>
<p>[9]链表判空 isEmpty()</p>
<p>[10]E removeFirst() : 删除并返回链表的首元素</p>
<h5 id="利用后序遍历来作">利用后序遍历来作</h5>
<p>序列化：只需要变化对根节点进行的操作，把操作移到最后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(TreeNode root,StringBuilder string)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        string.append(<span class="string">&quot;null&quot;</span>).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    find(root.left,string);</span><br><span class="line">    find(root.right,string);</span><br><span class="line">    string.append(root.val).append(<span class="string">&quot;,&quot;</span>);  <span class="comment">//调整到最后</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反序列化：因为字符串是通过后序遍历得到的，因此要将字符串变成二叉树时也要用后序遍历的观点看待字符串。</p>
<img align = "center" src = "https://cdn.jsdelivr.net/gh/winterwintersweet/image/202201082146622.png" width = "220" height = "160">
<p>先将字符串变成字符串链表好操作</p>
<p>最后一个元素是根，然后生成的是右子树，然后生成左子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">deFind</span><span class="params">(LinkedList&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String str = list.removeLast();</span><br><span class="line">    <span class="keyword">if</span>(str.equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(str));</span><br><span class="line">    root.right = deFind(list);</span><br><span class="line">    root.left = deFind(list);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="层次遍历的方法">层次遍历的方法</h5>
<h6 id="层次遍历的框架">层次遍历的框架</h6>
<p>层次遍历不涉及递归</p>
<p>如果给的是空树那么直接返回，</p>
<p>建立一个队列，存入根节点</p>
<p>开始循环，把这个根节点拿出来进行操作，接着向队列中存入该节点的左子树根节点和右子树根节点，循环条件是队列不空。</p>
<p>另外：用层次遍历的结果建立二叉树（即反序列化）的过程也是层次遍历一棵二叉树的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">    q.offer(root);    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        TreeNode node = q.poll();</span><br><span class="line">        <span class="comment">/***层次遍历要做的事情***/</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(root.val);</span><br><span class="line">        &#125;	</span><br><span class="line">        <span class="comment">/***层次遍历要做的事情***/</span></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            q.offer(node.left);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right !== <span class="keyword">null</span>)&#123;</span><br><span class="line">            q.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="此题代码">此题代码</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*主函数：将二叉树序列化为字符串*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;  <span class="comment">//和递归的结束没关系，这不是递归，这是层次遍历，这里的意思是如果给的树直接是空树，那么返回空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;  <span class="comment">//注意这里边都是新建的结点node，不是root,说明只是当前这个结点的左右子树，没有递归</span></span><br><span class="line">            TreeNode node = q.poll();</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                str.append(<span class="string">&quot;null&quot;</span>).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            str.append(node.val).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            q.offer(node.left);</span><br><span class="line">            q.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*主函数：将字符串反序列化成一棵二叉树*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.isEmpty())&#123;  <span class="comment">//这里和上面一样，如果给的字符串直接是空串，那么直接返回空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] nodes = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(nodes[<span class="number">0</span>]));     </span><br><span class="line">        q.offer(root);       </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nodes.length;)&#123;</span><br><span class="line">            TreeNode node = q.poll();</span><br><span class="line">            <span class="comment">//形成父节点左子树的根节点，并将该节点加入队列</span></span><br><span class="line">            String left = nodes[i++];</span><br><span class="line">            <span class="keyword">if</span>(!left.equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(left));</span><br><span class="line">                q.offer(node.left);                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//形成父节点右子树的的根节点，并将该节点加入队列</span></span><br><span class="line">            String right = nodes[i++];</span><br><span class="line">            <span class="keyword">if</span>(!right.equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(right));</span><br><span class="line">                q.offer(node.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               node.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉搜索树】538 把二叉搜索树转换为累加树</title>
    <url>/2022/01/18/22-10-09/</url>
    <content><![CDATA[<h5 id="题目">题目</h5>
<p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538 把二叉搜索树转换为累加树</a></p>
<h5 id="思路">思路</h5>
<p>对于每一个结点node，把所有大于等于node.val的结点的值都加起来，赋给node。由此想到了通过右根左的中序遍历形成BST的降序排列，利用sum记录大于等于node.val的所有节点的值之和。</p>
<span id="more"></span>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*辅助函数，中序遍历BST，在中序遍历的位置改变每个节点的值。 */</span></span><br><span class="line">    <span class="comment">/*先遍历右子树，再处理结点，再遍历左子树，形成降序序列 */</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.right);</span><br><span class="line">        sum = sum + root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉树】652 寻找重复的子树</title>
    <url>/2022/01/05/23-35-48/</url>
    <content><![CDATA[<h1>题目</h1>
<p><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">652 寻找重复的子树</a></p>
<h1>思路</h1>
<p><strong>1.整体思路</strong>：找到以每个结点为根的子树长什么样子，然后找出其中相同的。</p>
<span id="more"></span>
<p><strong>2.如何找到以每个结点为根的子树长什么样子？</strong></p>
<p>对每个子树进行遍历形成遍历序列，如果是空则用“#”代替</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">subTitle</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String left = find(root.left);</span><br><span class="line">    String right = find(root.right);</span><br><span class="line">    String subTree = left + <span class="string">&quot;,&quot;</span> + right + <span class="string">&quot;,&quot;</span> + root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.如何找出其中相同的？</strong></p>
<p>利用HashMap存储子树序列与对应的该子树序列的个数，用LinkedList存储具有相同结构的子树的根节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> time = map.getOrDefault(subTree,<span class="number">0</span>);  <span class="comment">//获得subTree对应的值，如果map中还没有subTree，那么返回的是0</span></span><br><span class="line"><span class="keyword">if</span>(time == <span class="number">1</span>)&#123;</span><br><span class="line">       list.add(root);</span><br><span class="line">&#125;</span><br><span class="line">map.put(subTree,time + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h1>代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*存储以每个结点为根的树的序列和对应的个数*/</span></span><br><span class="line">    HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/*存储具有相同结构的子树的根结点*/</span></span><br><span class="line">    LinkedList&lt;TreeNode&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">/*主函数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        find(root);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**找具有相同结构的子树，并把根节点放到list集合中 */</span></span><br><span class="line">    <span class="function">String <span class="title">find</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String left = find(root.left);</span><br><span class="line">        String right = find(root.right);</span><br><span class="line">        String subTree = left + <span class="string">&quot;,&quot;</span> + right + <span class="string">&quot;,&quot;</span> + root.val;</span><br><span class="line">        <span class="keyword">int</span> time = map.getOrDefault(subTree,<span class="number">0</span>);  <span class="comment">//获得subTree对应的值，如果map中还没有subTree，那么返回的是0</span></span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">1</span>)&#123;</span><br><span class="line">            list.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(subTree,time + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> subTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉树】543 二叉树的直径</title>
    <url>/2022/01/11/21-13-28/</url>
    <content><![CDATA[<h5 id="题目">题目</h5>
<p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543 二叉树的直径</a></p>
<h5 id="思路一">思路一</h5>
<p><strong>分解的思路</strong>。</p>
<p>计算左子树的直径长度，计算右子树的直径长度，再计算根节点的直径长度，最后三者比较取最大值。</p>
<p>计算根节点直径长度的具体办法：左子树深度 + 右子树深度</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftDiameter = diameterOfBinaryTree(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightDiameter = diameterOfBinaryTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftMax = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightMax = depth(root.right);</span><br><span class="line">        <span class="keyword">int</span> rootDiameter = lef tMax + rightMax;</span><br><span class="line">        <span class="keyword">return</span> Math.max(rootDiameter,Math.max(leftDiameter,rightDiameter));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*计算二叉树的深度*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="思路二">思路二</h5>
<p><strong>遍历的思路</strong></p>
<p>计算二叉树的深度，在计算二叉树的深度的过程中顺便在后序遍历的位置计算每个节点的直径长度，并不断更新最大值</p>
<h5 id="代码二">代码二</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxDiameter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*辅助函数：计算二叉树的深度，在计算二叉树的深度的过程中顺便在后序遍历的位置计算每个节点的直径长度，并不断更新最大值*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = depth(root.right);</span><br><span class="line">        <span class="comment">//后序遍历的位置</span></span><br><span class="line">        <span class="keyword">int</span> rootDiameter = leftDepth + rightDepth;  <span class="comment">//计算根节点的直径长度</span></span><br><span class="line">        maxDiameter = Math.max(maxDiameter,rootDiameter);  <span class="comment">//更新直径长度的最大值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftDepth,rightDepth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**注：**思路二更快。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉树】654 最大二叉树</title>
    <url>/2022/01/02/22-28-21/</url>
    <content><![CDATA[<h1>题目</h1>
<p><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654 最大二叉树</a></p>
<hr>
<h1>思路</h1>
<p><strong>1.结合例子理解最大二叉树的定义（以nums = [3,2,1,6,0,5]为例）</strong></p>
<p>二叉树的根是数组nums中的最大元素，即6。6左边的数字[3,2,1]全在6的左子树中出现。6右边的数字[0,5]全在6的右子树中出现。</p>
<span id="more"></span>
<p>[3,2,1]中再找最大的构成根节点，它左边的在左子树中出现，它右边的在右子树中出现。</p>
<p>[0,5]中再找最大的构成根节点，它左边的在左子树中出现，它右边的在右子树中出现。</p>
<p><strong>2.明确根节点该做的事</strong></p>
<p>根节点要做的事就是使自己成为自己所属范围内的几个数字中的最大的那个。</p>
<p><strong>3.套用框架</strong></p>
<p>使根节点等于最大值，再使其左子树的根节点称为最大值，右子树的根节点成为最大值。这是<strong>根左右的前序遍历框架</strong></p>
<hr>
<h1>代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给定nums[low...high],构造最大二叉树</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="comment">/***根节点要做的事：找出最大的元素构建一个结点***/</span></span><br><span class="line">        <span class="keyword">if</span>(low &gt; high)&#123;  <span class="comment">//注意只有大于的时候才能换，如果是等于的时候那么说明是有一个元素的，不能返回空。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = low; i &lt;= high; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; nums[i])&#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(max);</span><br><span class="line">        <span class="comment">//对最大值左右的元素做相同的操作构造根节点的左右子树</span></span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(nums,low,index - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(nums,index + <span class="number">1</span>,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1>语法</h1>
<p>1.数组元素的大小：<code>nums.size()</code></p>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉树】669 修剪二叉搜索树</title>
    <url>/2022/01/13/20-44-05/</url>
    <content><![CDATA[<h5 id="题目">题目</h5>
<p><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669 修剪二叉搜索树</a></p>
<h5 id="思路">思路</h5>
<p>用<strong>分解的思路</strong>，先修剪左子树，再修剪右子树，最后对根节点进行操作。后序遍历。</p>
<span id="more"></span>
<p>对于根节点就有两种情况：</p>
<p>1.root.val &lt; low，则只留下右子树</p>
<p>2.root.val &gt; high，则只留下左子树</p>
<p>3.rot.val在low 与high之间，那么不做任何处理。</p>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = trimBST(root.left,low,high);</span><br><span class="line">        root.right = trimBST(root.right,low,high);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low)&#123;</span><br><span class="line">            root = root.right;  <span class="comment">//root.val &lt; low，则只留下右子树</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; high)&#123;</span><br><span class="line">            root = root.left;  <span class="comment">//root.val &gt; high，则只留下左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉搜索树】98 验证二叉搜索树</title>
    <url>/2022/01/19/23-15-33/</url>
    <content><![CDATA[<h5 id="题目">题目</h5>
<p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98 验证二叉搜索树</a></p>
<h5 id="思路">思路</h5>
<p>依然利用BST左中右遍历得到递增序列的思想。在中序遍历的位置访问结点，如果结点的值小于或等于前一个结点的值，那么就不符合BST，返回false。</p>
<span id="more"></span>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> traverse(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isLeft = traverse(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= pre)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isRight = traverse(root.right);</span><br><span class="line">        <span class="keyword">return</span> isLeft &amp;&amp; isRight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="其他">其他</h5>
<p>int32位，能表示的范围：-2的31次方 - 2的31次方减1</p>
<p>long64位，能表示的范围：-2的63次方 - 2的63次方减1</p>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉搜索树】85 合法二叉搜索树</title>
    <url>/2022/03/01/22-43-24/</url>
    <content><![CDATA[<h1>题目</h1>
<p><a href="https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/">85 合法二叉搜索树</a></p>
<h1>思路</h1>
<p><strong>思路一</strong></p>
<p>对于一个二叉搜索树，要满足根节点的值大于左子树中所有节点的值，小于右子树中所有结点的值。即一个结点的值是有范围的。可<span id="more"></span>以设置一个函数来判断，参数有结点和结点的范围，这个范围是什么呢？对于根节点来说，是能取到的最小值到最大值之间，左子树根节点的范围是最小值到根节点的值，右子树根节点的范围是根节点的值到最大值。采用根左右的遍历思想。</p>
<p><strong>思路二</strong></p>
<p>利用中序遍历二叉搜索树必然有序来做，如果不满足有序则不是二叉搜索树</p>
<p><strong>思路三</strong></p>
<p>思路二是中序遍历的递归形式，中序遍历的递归形式可以转化为非递归形式。</p>
<h1>代码</h1>
<p>思路一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> judge(root,Long.MIN_VALUE,Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*自定义函数：判断每个结点是否符合BST的定义*/</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(TreeNode root,<span class="keyword">long</span> min,<span class="keyword">long</span> max)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果节点为空，则返回true</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根节点的值有一个范围</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= min || root.val &gt;= max)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树的根节点的值的范围是最小值到根节点的值，右子树根节点的值的范围是根节点的值到最大值</span></span><br><span class="line">        <span class="keyword">return</span> judge(root.left,min,root.val) &amp;&amp; judge(root.right,root.val,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode pre;  <span class="comment">//当前节点的前驱节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.right))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路三</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;  <span class="comment">//当前节点的前驱节点</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= root.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = root;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里总结一下中序遍历非递归形式的框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;():</span><br><span class="line"><span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**对结点进行处理**/</span></span><br><span class="line">    root = stack.pop();</span><br><span class="line">    <span class="comment">//处理</span></span><br><span class="line">    <span class="comment">/**对结点进行处理**/</span></span><br><span class="line">    root = root.right;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>《弃猫》</title>
    <url>/2022/01/07/15-35-07/</url>
    <content><![CDATA[<p><strong>书名</strong>：《弃猫》<br>
<strong>出版社</strong>：花城出版社<br>
<strong>作者</strong>：村上春树</p>
<span id="more"></span>
<img align = "center" src = "https://cdn.jsdelivr.net/gh/winterwintersweet/image/202201061617406.jpg" width = "270" height = "400">
<p align = "center"> <font size = "2"> 《弃猫》</font></p>
<h5 id="花城出版社还有哪些好书吗？">花城出版社还有哪些好书吗？</h5>
<p>《这边风景》《出梁庄记》《平原客》《遥远的向日葵地》《下弦月》《乙卯年雨雪》</p>
<p>《遥远的向日葵地》是李娟的作品，不错不错！👍</p>
<h5 id="这本书讲了什么？">这本书讲了什么？</h5>
<p>村上春树通过回忆和考证父亲的过去渐渐增加了对他的了解，同时也通过这种追忆探讨了偶然与必然之下的命运，对待历史的态度以及战争对人们命运的影响，总之，我觉得这本书在探讨的核心话题是<strong>命运</strong>。</p>
<h5 id="弃猫是什么意思？">弃猫是什么意思？</h5>
<p>弃猫就是被丢弃的猫，村上春树以“他和父亲去海边丢弃一只猫”这件事为开头写了这本书，故事的细节是这样的：父亲和他去海边丢弃一只猫，然后刚回到家却发现猫抢到二人前头先回了家。</p>
<blockquote>
<p>我还记得父亲那时一脸的惊讶。但他神情中的惊讶不久就转为叹服，最后好像还松了口气。</p>
</blockquote>
<p>丢猫这件事其实和父亲幼时的命运是暗合的，那时不少孩子多的家庭会把长子之外的孩子送给别家做养子或送到寺院当小和尚，父亲是家中的次子，曾被送到奈良的某座寺院，但似乎是因为父亲难以适应新的环境，就又被送回了老家，当父亲看到一只被自己丢弃的小猫竟然赶在自己前头回到了家，也会联想到自己幼时的命运吧？“叹服”和“松了口气”也就可以理解了。</p>
<h5 id="站谁一边？替谁说话？">站谁一边？替谁说话？</h5>
<p>村上春树在回忆父亲侵华战争时这样写到：</p>
<blockquote>
<p>一支连机械化都未完全实现，也难以指望燃料充足补给的战斗部队——马几乎是唯一的代步工具——要走这么远的路，一定是一趟异常艰难的苦行。（后略）</p>
</blockquote>
<p>侵华日军给中国人民带来了极其沉重的苦难，这里村上春树以作为军人身份的父亲的儿子的视角写日军行军困难，虽然表面上陈述事实，但我觉得连无可厚非都说不上，因为侵华的行为本身就是错误的。我想起了政治课上老师讲过的立场问题，所谓立场问题，就是站在谁这一边，为谁说话的问题，身为中国人，当然要站在中国人民这一方，为中国人民说话。</p>
<h5 id="金句与观点">金句与观点</h5>
<blockquote>
<p>最终，我们每一个人不过是把这份偶然当成独一无二来生活罢了。</p>
</blockquote>
]]></content>
      <categories>
        <category>书籍</category>
      </categories>
  </entry>
  <entry>
    <title>《记一忘三二》</title>
    <url>/2021/12/30/19-00-06/</url>
    <content><![CDATA[<h1>李娟记</h1>
<p>1.从前有人生了一个女儿，她决心要给她取一个最特别的名字，全世界独一无二的名字。为此她翻烂了字典，终于由一部电影得到启发。她激动极了。</p>
<span id="more"></span>
<p>她为她取名为“娟”。</p>
<p>是的……就是我……李娟……</p>
<p>2.每当我向人做自我介绍，对方一听往往立刻接口：“哦我也认识一个李娟。”我说：“是的，这个名字很普遍。“<strong>开场白万年不变</strong>。</p>
<p>2.话说我从小就佩服“佚名”这个人，到处发表作品，创作跨美术文学诗歌多届，还活了好几千年。</p>
<p>3.长久以来，我的写作全都围绕个人生活展开。于是常有人替我担心：人的经历是有限的，万一把生活写完了怎么办？我不能理解“写完”是什么意思。好像写作就是开一瓶饮料，喝完拉倒。<strong>可我打开的明明是一条河，滔滔不绝，手忙脚乱也不能汲取其一二。总是这样——写着写着，记忆的某个点突然被刚成形的语言触动，另外的一扇门被打开。推开那扇门，又面对好几条路……对我来说，写作更像是无边无际的旅行，是源源不断地开启和收获。总之，只要一开始动笔，往往刹不住脚——不过，也可能是因为我话痨</strong>。</p>
<p>3.幸亏自己勤快，大事小事统统记下来再说。每次翻看自己成山成海乱七八糟的电脑文件夹便无比庆幸——像最贪得无厌的人那样庆幸。<strong>好吧，常年在河中拦网守候的人，总比隔三岔五空着手到水边碰运气的人收获稍多</strong>。</p>
<hr>
<h1>台湾记</h1>
<p>1.自从我妈从台湾回来，可嫌弃我们大陆了，一会儿嫌乌鲁木齐太吵，一会又嫌红墩乡太脏。整天一副”这日子简直没法过下去“的模样。抱怨完毕，换下衣服，立刻投入清理牛圈打扫鸡粪的劳动中，毫不含糊。</p>
<p>2.之后，足足又半年的时间，无论和谁聊天，她老人家总能在第三句或第四句话上成功地把话题引向台湾。</p>
<p>如果对方说某店的某道菜不错。</p>
<p>她立刻说：嗨！台湾的什么什么那才叫好吃呢！</p>
<p>接下来从台湾小吃说到环岛七日游。</p>
<p>对方：好久没下雨了。</p>
<p>她：台湾天天下雨！</p>
<p>接下来，从台湾的雨说到环岛七日游。</p>
<p>对方，这两天感冒了。</p>
<p>她：我也不舒服，从台湾回来，累的躺了好几天。</p>
<p>接下来，环岛七日游。</p>
<hr>
<h1>信仰记</h1>
<p>1.那年夏天，很长一段时间里她一个人住在遥远无人的荒野中看守着两百亩葵花地。整个夏天独自陷没在广阔的大地中，面朝黄土，除草、打杈、浇地，安静地侍弄着农活。有时干着干着，突然会孤独地想起某首赞美歌来，于是边唱边干活。茫茫荒野，自得其乐。</p>
<p>2.不管怎么说，把我妈这么吊儿郎当地人扔进一群郑重认真地人中间，多少还是有些益处的，至少有了些好的约束。最明显的变化就是骂人没有那么脏了。以前脱口就是”你姑的腿、你二的蛋“之类，虽野蛮有趣，毕竟不成体统。现在呢，一旦发怒，就只会不断地重复：”你这个魔鬼！你要下地狱！“总算文雅多了。</p>
<hr>
<h1>扫雪记</h1>
<p>1.把清扫积雪说成”扫“雪，实在太含蓄了，说”铲“雪、”打“雪、”砍“雪都不为过啊。那可真是个力气活，用剁铲砍，用推板刮，拼命在雪堆里刨开一条通道，杀出一条血路。雪是轻盈浪漫的，可一旦堆积起来，便沉重又踏实，不近人情。</p>
<p>2.真想多交几个男朋友……帮忙扫雪……</p>
<hr>
<h1>挨打记</h1>
<p>我当然可以原谅她。”原谅“是非常容易就能做到的事情。可是，我有什么资格去原谅她呢？这样的暴力和恶意，恐怕只有上帝和佛祖才能原谅吧。我只是一个凡人，我化解不了这种阴暗。尤其是我自己心里的黑暗。</p>
<hr>
<h1>藏钱记</h1>
<p>她说：”要是我有什么三长两短，你回到家，推门左转，门背后架着碎麦子麻袋垛的那排木板下有一只破纸箱，上面盖着几件旧衣服，下面有八千块钱……然后你继续往里走，仓库尽头通向鸡窝那扇门背后有一个放着破钉子烂螺帽的锈铁盆，你扒拉开，里面有个塑料袋装着两千块……你再推开门往里走，鸡圈西墙角的铁皮炉子后有一个大灰坑，你扒开，里面有一大包零钱……你再出门向东……“</p>
<h1>风华记</h1>
<p>能有风华这样一个一直惦记着自己的朋友很幸福。</p>
<hr>
<h1>飞机记</h1>
<p>我家邻居大叔以前坐飞机旅行结婚。飞到半途乘务员给大家发了纸笔，叫写遗书……从此对飞机产生巨大阴影。</p>
<hr>
<h1>老师记</h1>
<p>1.回想起过去，老师有些动情：“李娟，我早就看出来，你从小就与众不同，想法独特。美术课自由画画时，别的同学都只会画个小猫小狗小房子，只有你画的是大海、风帆和海鸥，还有天边的月亮……那时候，我就知道你志向高远，非同寻常……”——拉倒吧，那为啥还管我叫猪头小队长？</p>
<p>2.在假期的漫长时光里，我常常一个人跑到那里去看我的画。那个大厅似乎从来不关门，不上锁。我一个人走进去，沿着展道熟练地东拐西拐，在最尽头的角落里找到我的画，长时间地抬头看……当时，它几乎是我的唯一荣耀。</p>
<p>3.这么笨拙胆怯的一幅画，我才不信我那位老师能看出什么玄机来。我想，更多的，只是他善意的鼓励吧。他就是那么善良，无所畏惧、竭尽全力地善良着。</p>
<hr>
<h1>野猫记</h1>
<p>1.温柔的赛虎，善良的赛虎，浑身毛茸茸热乎乎的赛虎，在无数个炉火熄灭的寒冷冬夜，是猫咪们最甜美的依傍。宽绰的狗窝被塞得满满当当，身上还趴了俩。作为一只狗，可能会略感屈辱，但作为隆冬寒夜里同样孤独脆弱的生命，我猜它也会依恋此种舒适和安全感吧。</p>
<p>2.小奶猫之可爱！让人恨不能揣在口袋里走哪儿带哪儿，时不时掏出来搓搓揉揉，还总会令人自私地叹息：“要是永远都这么一点点永远长不大就好了！”虽然许多动物小时候都是可爱的，但在我看来什么都赶不上猫。由尤其当猫咪以征服世界的雄心来对付一个线团或一块破布头或自己的尾巴时，简直能令人跪地臣服。</p>
<p>3.它美丽、温顺、充满喜悦。它对我们的信任以及对我们这个家的依恋令人惊讶又幸福。它活在世上像在深深地安慰着我们。</p>
<hr>
<h1>过年记</h1>
<p>追根究底，这一切可能都源于我外婆的教育。我外婆省下了压岁钱和新衣服，却令我疏远世事，冷静又孤独。**冷静可能不是什么好事，冷静也许就是自我和自私。可孤独这种东西却太宝贵。孤独是强大的独立，令我从不曾畏惧过人生的变故。当然，这种话说起来又空又大。可是真的，在每一个普天同庆的特殊日子里，我远远站着，照常生活，像是没有行李的旅人，又穷，又轻松。**我的幸福只有一种源头，它只滋生于内心，它和外部的现实秩序没有一点关系。</p>
<hr>
<h1>阅读记</h1>
<p>1.那可能是我生命之初的第一场阅读，犹如壳中小鸡啄开坚硬蛋壳的第一个小小孔隙。</p>
<p>阅读令我打开了通往更大也更黑的世界的一扇门。从此，只要是印有汉字的东西都会令我饥渴阅读。</p>
<p>2.——全都是毫无选择的阅读，全然接受，鲸吞海纳，吃干抹净……当年的耳语者还不曾走开，只对我一个人透漏唯一的秘密。</p>
<hr>
<h1>冰箱记</h1>
<p>然而好景不长，没过多久我和我妈绝交了。</p>
<p>怎么说呢，我妈这人吧，交个朋友还是蛮不错的。做母女，实在艰难。若我们俩是夫妻，早就离婚几百次了。</p>
<hr>
<h1>疑惑记</h1>
<p>我想象他心中的疑惑，以及无法想象的以光年计算以黑洞填充以生死相隔的巨大无边的陌生感。</p>
<hr>
<h1>古老记</h1>
<p>那时，自然的气息除了香气，还有臭气。但香和臭是公平存在于这个世界上的，不是对立的。只要能忍受的东西，人们都不会太排斥。后来人们对臭味的否定，我觉得不过是偏见。没有人天生就喜欢一种气味而讨厌另一种气味。文明的暗示而已。于是，只要是让人不舒服的就都是不好的、不对的、不正常的。渐渐地，人越来越强势，可以按喜好操控一切。同时也越来越脆弱，不能忍受的东西越来越多。</p>
<hr>
<h1>渴望记</h1>
<p>1.在漫长的冬天里，那盘磁带被这个年轻人听了一遍又一遍。后来他决定学习这些歌。他反复倒带，一句句摸索歌词，将陌生的语言用阿拉伯字母拼注出来。冬天过去后，他便学会了那盘磁带里的所有歌。</p>
<p>2.春天，雪化了，牧羊人离开了森林，重新回到了自己的羊群之中。但是，他的人生悄然改变。他的世界还是那么大，但是多开了一扇美丽的窗子。</p>
]]></content>
      <categories>
        <category>书籍</category>
      </categories>
  </entry>
  <entry>
    <title>【二叉树】543 二叉树的直径</title>
    <url>/2022/03/04/23-30-37/</url>
    <content><![CDATA[<h1>题目</h1>
<p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700 二叉搜索树中的搜索</a></p>
<h1>思路</h1>
<p><strong>思路一</strong></p>
<p>如果是对一棵普通的二叉树进行搜索，那么可以用这个框架。</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">searchTree</span><span class="params">(TreeNode root,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val == val)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在左子树中找，在右子树中找，如果那边找到了就返回哪边</span></span><br><span class="line">    TreeNode left = searchTree(root.left,val);</span><br><span class="line">    TreeNode right = searchTree(root.right,val);</span><br><span class="line">    <span class="keyword">if</span>(left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思路二</strong></p>
<p>这是一棵二叉搜索树，要充分利用左小右大的性质。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">searchTree</span><span class="params">(TreeNode root,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//当目标值小于根节点就去左子树找</span></span><br><span class="line">    <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> searchTree(root.left,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当目标值大于根节点就去右子树找</span></span><br><span class="line">    <span class="keyword">if</span>(val &gt; root.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> searchTree(root.right,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不属于上述两种情况就说明当下这个结点就是要找的结点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
</search>
